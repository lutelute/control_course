<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬6å›ï¼šå®‰å®šæ€§ã¨æ¥µ</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0f172a;
            --card: #1e293b;
            --stable: #22c55e;
            --unstable: #ef4444;
            --marginal: #eab308;
            --accent: #3b82f6;
            --text: #e2e8f0;
            --dim: #64748b;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Noto Sans JP', sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; padding: 1.5rem; }
        header { text-align: center; padding: 2rem 0; }
        h1 { font-size: 2rem; color: var(--accent); }
        .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5rem; }
        .card { background: var(--card); border-radius: 12px; padding: 1.5rem; }
        .card-full { grid-column: 1 / -1; }
        .card-title { color: var(--accent); margin-bottom: 1rem; }
        canvas { width: 100%; height: 300px; border-radius: 8px; background: rgba(0,0,0,0.3); cursor: crosshair; }
        .pole-canvas { aspect-ratio: 1; height: auto; }
        .status-box { padding: 1rem; border-radius: 8px; text-align: center; font-size: 1.2rem; font-weight: 500; margin: 1rem 0; }
        .stable { background: rgba(34, 197, 94, 0.2); border: 2px solid var(--stable); color: var(--stable); }
        .unstable { background: rgba(239, 68, 68, 0.2); border: 2px solid var(--unstable); color: var(--unstable); }
        .marginal { background: rgba(234, 179, 8, 0.2); border: 2px solid var(--marginal); color: var(--marginal); }
        .controls { display: flex; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0; }
        .btn { padding: 0.5rem 1rem; background: var(--accent); border: none; border-radius: 6px; color: white; cursor: pointer; }
        .btn:hover { opacity: 0.9; }
        .info-box { background: rgba(59, 130, 246, 0.1); border-left: 3px solid var(--accent); padding: 1rem; margin: 0.5rem 0; font-size: 0.9rem; }
        .eigenvalue-list { font-family: 'JetBrains Mono', monospace; margin: 0.5rem 0; }
        .eigenvalue-item { display: flex; justify-content: space-between; padding: 0.3rem 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .legend { display: flex; gap: 1rem; margin-top: 0.5rem; font-size: 0.85rem; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 0.3rem; }
        .legend-color { width: 12px; height: 12px; border-radius: 3px; }
        .slider-group { margin: 0.5rem 0; }
        .slider-group label { display: flex; justify-content: space-between; color: var(--dim); font-size: 0.9rem; }
        input[type="range"] { width: 100%; margin-top: 0.3rem; }
        .region-label { position: absolute; font-size: 0.8rem; color: var(--dim); }
        @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ç¬¬6å›ï¼šå®‰å®šæ€§ã¨æ¥µ</h1>
            <p style="color: var(--dim);">Stability and Pole Placement</p>
        </header>
        
        <div class="grid">
            <!-- æ¥µé…ç½® -->
            <div class="card">
                <h3 class="card-title">ğŸ¯ æ¥µé…ç½®ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§æ¥µã‚’è¿½åŠ ï¼‰</h3>
                <canvas id="poleCanvas" class="pole-canvas"></canvas>
                <div class="controls">
                    <button class="btn" onclick="clearPoles()">ã‚¯ãƒªã‚¢</button>
                    <button class="btn" onclick="addRandomPoles()">ãƒ©ãƒ³ãƒ€ãƒ è¿½åŠ </button>
                    <button class="btn" onclick="addStablePoles()">å®‰å®šãªæ¥µ</button>
                    <button class="btn" onclick="addUnstablePole()">ä¸å®‰å®šãªæ¥µ</button>
                </div>
                <div id="stabilityStatus" class="status-box stable">ã‚·ã‚¹ãƒ†ãƒ ã¯å®‰å®š</div>
            </div>
            
            <!-- æ™‚é–“å¿œç­” -->
            <div class="card">
                <h3 class="card-title">ğŸ“ˆ æ™‚é–“å¿œç­”ï¼ˆè‡ªç”±å¿œç­”ï¼‰</h3>
                <canvas id="responseCanvas"></canvas>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background: var(--accent);"></div>x(t)</div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--stable);"></div>åŒ…çµ¡ç·š</div>
                </div>
            </div>
            
            <!-- å›ºæœ‰å€¤ãƒªã‚¹ãƒˆ -->
            <div class="card">
                <h3 class="card-title">ğŸ“‹ å›ºæœ‰å€¤ï¼ˆæ¥µï¼‰ã®ãƒªã‚¹ãƒˆ</h3>
                <div id="eigenvalueList" class="eigenvalue-list">
                    <p style="color: var(--dim);">æ¥µã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¿½åŠ ã—ã¦ãã ã•ã„</p>
                </div>
                <div class="info-box">
                    <strong>å®‰å®šæ¡ä»¶:</strong> ã™ã¹ã¦ã®æ¥µã®å®Ÿéƒ¨ãŒè² 
                    <br>Re(Î»áµ¢) < 0 for all i
                </div>
            </div>
            
            <!-- å¿œç­”ç‰¹æ€§ -->
            <div class="card">
                <h3 class="card-title">âš™ï¸ å¿œç­”ç‰¹æ€§</h3>
                <div class="eigenvalue-list">
                    <div class="eigenvalue-item">
                        <span>æ”¯é…æ¥µ:</span>
                        <span id="dominantPole">-</span>
                    </div>
                    <div class="eigenvalue-item">
                        <span>æ¨å®šæ•´å®šæ™‚é–“:</span>
                        <span id="settlingTime">-</span>
                    </div>
                    <div class="eigenvalue-item">
                        <span>æŒ¯å‹•å‘¨æ³¢æ•°:</span>
                        <span id="oscillationFreq">-</span>
                    </div>
                    <div class="eigenvalue-item">
                        <span>æ¸›è¡°æ¯”:</span>
                        <span id="dampingRatio">-</span>
                    </div>
                </div>
            </div>
            
            <!-- 2æ¬¡ç³»ã®æ¥µé…ç½® -->
            <div class="card card-full">
                <h3 class="card-title">ğŸ”¬ 2æ¬¡ç³»ã®æ¥µã¨å¿œç­”ã®é–¢ä¿‚</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div>
                        <div class="slider-group">
                            <label>æ¸›è¡°æ¯” Î¶: <span id="zetaVal">0.5</span></label>
                            <input type="range" id="zetaSlider" min="0" max="2" step="0.05" value="0.5">
                        </div>
                        <div class="slider-group">
                            <label>å›ºæœ‰è§’å‘¨æ³¢æ•° Ï‰n: <span id="wnVal">1.0</span> rad/s</label>
                            <input type="range" id="wnSlider" min="0.1" max="5" step="0.1" value="1">
                        </div>
                        <div class="info-box" style="margin-top: 1rem;">
                            <strong>æ¥µã®ä½ç½®:</strong><br>
                            <span id="secondOrderPoles">s = -0.5 Â± 0.866j</span>
                        </div>
                    </div>
                    <div>
                        <canvas id="secondOrderCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // æ¥µã®ãƒªã‚¹ãƒˆï¼ˆè¤‡ç´ æ•°ï¼‰
        let poles = [];
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹
        const poleCanvas = document.getElementById('poleCanvas');
        const poleCtx = poleCanvas.getContext('2d');
        const responseCanvas = document.getElementById('responseCanvas');
        const responseCtx = responseCanvas.getContext('2d');
        const secondOrderCanvas = document.getElementById('secondOrderCanvas');
        const secondOrderCtx = secondOrderCanvas.getContext('2d');
        
        function setupCanvas(canvas, ctx) {
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        }
        
        function initCanvases() {
            setupCanvas(poleCanvas, poleCtx);
            setupCanvas(responseCanvas, responseCtx);
            setupCanvas(secondOrderCanvas, secondOrderCtx);
            drawAll();
        }
        
        // æ¥µã‚’ã‚¯ãƒªãƒƒã‚¯ã§è¿½åŠ 
        poleCanvas.addEventListener('click', (e) => {
            const rect = poleCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const w = rect.width;
            const h = rect.height;
            const cx = w / 2;
            const cy = h / 2;
            const scale = Math.min(w, h) / 8;
            
            const re = (x - cx) / scale;
            const im = (cy - y) / scale;
            
            // è¤‡ç´ å…±å½¹ãƒšã‚¢ã¨ã—ã¦è¿½åŠ ï¼ˆè™šéƒ¨ãŒ0ã§ãªã„å ´åˆï¼‰
            if (Math.abs(im) > 0.1) {
                poles.push({ re, im });
                poles.push({ re, im: -im });
            } else {
                poles.push({ re, im: 0 });
            }
            
            drawAll();
        });
        
        function clearPoles() {
            poles = [];
            drawAll();
        }
        
        function addRandomPoles() {
            const re = -Math.random() * 3 - 0.5;
            const im = (Math.random() - 0.5) * 4;
            if (Math.abs(im) > 0.2) {
                poles.push({ re, im });
                poles.push({ re, im: -im });
            } else {
                poles.push({ re, im: 0 });
            }
            drawAll();
        }
        
        function addStablePoles() {
            poles.push({ re: -1, im: 1 });
            poles.push({ re: -1, im: -1 });
            drawAll();
        }
        
        function addUnstablePole() {
            poles.push({ re: 0.5, im: 0 });
            drawAll();
        }
        
        function drawPoleCanvas() {
            const w = poleCanvas.getBoundingClientRect().width;
            const h = poleCanvas.getBoundingClientRect().height;
            
            poleCtx.fillStyle = 'rgba(0,0,0,0.3)';
            poleCtx.fillRect(0, 0, w, h);
            
            const cx = w / 2;
            const cy = h / 2;
            const scale = Math.min(w, h) / 8;
            
            // å·¦åŠå¹³é¢ï¼ˆå®‰å®šé ˜åŸŸï¼‰ã‚’è–„ãå¡—ã‚‹
            poleCtx.fillStyle = 'rgba(34, 197, 94, 0.1)';
            poleCtx.fillRect(0, 0, cx, h);
            
            // å³åŠå¹³é¢ï¼ˆä¸å®‰å®šé ˜åŸŸï¼‰
            poleCtx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            poleCtx.fillRect(cx, 0, w - cx, h);
            
            // ã‚°ãƒªãƒƒãƒ‰
            poleCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            poleCtx.lineWidth = 1;
            for (let i = -3; i <= 3; i++) {
                poleCtx.beginPath();
                poleCtx.moveTo(cx + i * scale, 0);
                poleCtx.lineTo(cx + i * scale, h);
                poleCtx.stroke();
                poleCtx.beginPath();
                poleCtx.moveTo(0, cy + i * scale);
                poleCtx.lineTo(w, cy + i * scale);
                poleCtx.stroke();
            }
            
            // è»¸
            poleCtx.strokeStyle = 'rgba(255,255,255,0.5)';
            poleCtx.lineWidth = 2;
            poleCtx.beginPath();
            poleCtx.moveTo(0, cy);
            poleCtx.lineTo(w, cy);
            poleCtx.moveTo(cx, 0);
            poleCtx.lineTo(cx, h);
            poleCtx.stroke();
            
            // è™šè»¸ã‚’å¼·èª¿
            poleCtx.strokeStyle = 'rgba(234, 179, 8, 0.5)';
            poleCtx.setLineDash([5, 5]);
            poleCtx.beginPath();
            poleCtx.moveTo(cx, 0);
            poleCtx.lineTo(cx, h);
            poleCtx.stroke();
            poleCtx.setLineDash([]);
            
            // æ¥µã‚’ãƒ—ãƒ­ãƒƒãƒˆ
            poles.forEach(p => {
                const x = cx + p.re * scale;
                const y = cy - p.im * scale;
                
                const color = p.re < 0 ? 'var(--stable)' : (p.re > 0 ? 'var(--unstable)' : 'var(--marginal)');
                poleCtx.strokeStyle = color;
                poleCtx.lineWidth = 3;
                poleCtx.beginPath();
                poleCtx.moveTo(x - 8, y - 8);
                poleCtx.lineTo(x + 8, y + 8);
                poleCtx.moveTo(x + 8, y - 8);
                poleCtx.lineTo(x - 8, y + 8);
                poleCtx.stroke();
            });
            
            // ãƒ©ãƒ™ãƒ«
            poleCtx.fillStyle = 'rgba(255,255,255,0.6)';
            poleCtx.font = '12px JetBrains Mono';
            poleCtx.fillText('Re (Ïƒ)', w - 50, cy - 10);
            poleCtx.fillText('Im (jÏ‰)', cx + 10, 20);
            poleCtx.fillStyle = 'rgba(34, 197, 94, 0.6)';
            poleCtx.fillText('å®‰å®š', 20, 30);
            poleCtx.fillStyle = 'rgba(239, 68, 68, 0.6)';
            poleCtx.fillText('ä¸å®‰å®š', w - 50, 30);
        }
        
        function drawResponseCanvas() {
            const w = responseCanvas.getBoundingClientRect().width;
            const h = responseCanvas.getBoundingClientRect().height;
            
            responseCtx.fillStyle = 'rgba(0,0,0,0.3)';
            responseCtx.fillRect(0, 0, w, h);
            
            if (poles.length === 0) {
                responseCtx.fillStyle = 'var(--dim)';
                responseCtx.font = '14px Noto Sans JP';
                responseCtx.fillText('æ¥µã‚’è¿½åŠ ã™ã‚‹ã¨å¿œç­”ãŒè¡¨ç¤ºã•ã‚Œã¾ã™', 50, h/2);
                return;
            }
            
            const margin = { top: 20, right: 20, bottom: 30, left: 50 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            // å¿œç­”è¨ˆç®—
            const maxT = 10;
            const dt = 0.02;
            const data = [];
            let maxVal = 1;
            
            for (let t = 0; t <= maxT; t += dt) {
                let response = 0;
                const processedPairs = new Set();
                
                poles.forEach((p, idx) => {
                    if (processedPairs.has(idx)) return;
                    
                    // è¤‡ç´ å…±å½¹ãƒšã‚¢ã‚’è¦‹ã¤ã‘ã‚‹
                    const conjugateIdx = poles.findIndex((q, j) => 
                        j !== idx && Math.abs(q.re - p.re) < 0.01 && Math.abs(q.im + p.im) < 0.01
                    );
                    
                    if (conjugateIdx !== -1 && p.im !== 0) {
                        processedPairs.add(conjugateIdx);
                        // è¤‡ç´ å…±å½¹ãƒšã‚¢
                        response += 2 * Math.exp(p.re * t) * Math.cos(p.im * t);
                    } else if (Math.abs(p.im) < 0.01) {
                        // å®Ÿæ•°æ¥µ
                        response += Math.exp(p.re * t);
                    }
                });
                
                data.push({ t, y: response });
                if (Math.abs(response) < 100) maxVal = Math.max(maxVal, Math.abs(response));
            }
            
            maxVal = Math.min(maxVal, 10);
            
            const toX = (t) => margin.left + (t / maxT) * plotW;
            const toY = (y) => margin.top + plotH/2 - (y / maxVal) * (plotH/2) * 0.9;
            
            // ã‚°ãƒªãƒƒãƒ‰
            responseCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            responseCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = margin.top + (plotH / 4) * i;
                responseCtx.beginPath();
                responseCtx.moveTo(margin.left, y);
                responseCtx.lineTo(w - margin.right, y);
                responseCtx.stroke();
            }
            
            // ã‚¼ãƒ­ãƒ©ã‚¤ãƒ³
            responseCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            responseCtx.beginPath();
            responseCtx.moveTo(margin.left, toY(0));
            responseCtx.lineTo(w - margin.right, toY(0));
            responseCtx.stroke();
            
            // å¿œç­”æ›²ç·š
            responseCtx.strokeStyle = 'var(--accent)';
            responseCtx.lineWidth = 2;
            responseCtx.beginPath();
            let started = false;
            data.forEach((p, i) => {
                if (Math.abs(p.y) > maxVal * 2) return;
                const y = Math.max(margin.top, Math.min(h - margin.bottom, toY(p.y)));
                if (!started) { responseCtx.moveTo(toX(p.t), y); started = true; }
                else responseCtx.lineTo(toX(p.t), y);
            });
            responseCtx.stroke();
        }
        
        function updateEigenvalueList() {
            const list = document.getElementById('eigenvalueList');
            if (poles.length === 0) {
                list.innerHTML = '<p style="color: var(--dim);">æ¥µã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¿½åŠ ã—ã¦ãã ã•ã„</p>';
                return;
            }
            
            let html = '';
            const shown = new Set();
            poles.forEach((p, i) => {
                const key = `${p.re.toFixed(2)},${Math.abs(p.im).toFixed(2)}`;
                if (shown.has(key)) return;
                shown.add(key);
                
                const color = p.re < 0 ? 'var(--stable)' : (p.re > 0 ? 'var(--unstable)' : 'var(--marginal)');
                const status = p.re < 0 ? 'å®‰å®š' : (p.re > 0 ? 'ä¸å®‰å®š' : 'è‡¨ç•Œ');
                
                let poleStr = p.re.toFixed(2);
                if (Math.abs(p.im) > 0.01) {
                    poleStr += ` Â± ${Math.abs(p.im).toFixed(2)}j`;
                }
                
                html += `<div class="eigenvalue-item">
                    <span>Î» = ${poleStr}</span>
                    <span style="color: ${color}">${status}</span>
                </div>`;
            });
            list.innerHTML = html;
        }
        
        function updateStabilityStatus() {
            const status = document.getElementById('stabilityStatus');
            const isStable = poles.every(p => p.re < 0);
            const isMarginal = poles.some(p => Math.abs(p.re) < 0.01);
            
            if (poles.length === 0) {
                status.className = 'status-box stable';
                status.textContent = 'ã‚·ã‚¹ãƒ†ãƒ ã¯å®‰å®šï¼ˆæ¥µãªã—ï¼‰';
            } else if (isStable && !isMarginal) {
                status.className = 'status-box stable';
                status.textContent = 'âœ“ ã‚·ã‚¹ãƒ†ãƒ ã¯æ¼¸è¿‘å®‰å®š';
            } else if (isMarginal && !poles.some(p => p.re > 0)) {
                status.className = 'status-box marginal';
                status.textContent = 'âš  ã‚·ã‚¹ãƒ†ãƒ ã¯è‡¨ç•Œå®‰å®š';
            } else {
                status.className = 'status-box unstable';
                status.textContent = 'âœ— ã‚·ã‚¹ãƒ†ãƒ ã¯ä¸å®‰å®š';
            }
        }
        
        function updateResponseCharacteristics() {
            if (poles.length === 0) {
                document.getElementById('dominantPole').textContent = '-';
                document.getElementById('settlingTime').textContent = '-';
                document.getElementById('oscillationFreq').textContent = '-';
                document.getElementById('dampingRatio').textContent = '-';
                return;
            }
            
            // æ”¯é…æ¥µã‚’è¦‹ã¤ã‘ã‚‹
            let dominant = poles[0];
            poles.forEach(p => {
                if (p.re > dominant.re) dominant = p;
            });
            
            let domStr = dominant.re.toFixed(2);
            if (Math.abs(dominant.im) > 0.01) domStr += ` Â± ${Math.abs(dominant.im).toFixed(2)}j`;
            document.getElementById('dominantPole').textContent = domStr;
            
            // æ•´å®šæ™‚é–“
            if (dominant.re < 0) {
                const ts = 4 / Math.abs(dominant.re);
                document.getElementById('settlingTime').textContent = ts.toFixed(2) + ' s';
            } else {
                document.getElementById('settlingTime').textContent = 'âˆ (ç™ºæ•£)';
            }
            
            // æŒ¯å‹•å‘¨æ³¢æ•°
            if (Math.abs(dominant.im) > 0.01) {
                const freq = Math.abs(dominant.im) / (2 * Math.PI);
                document.getElementById('oscillationFreq').textContent = freq.toFixed(3) + ' Hz';
            } else {
                document.getElementById('oscillationFreq').textContent = '0 (éæŒ¯å‹•)';
            }
            
            // æ¸›è¡°æ¯”
            const wn = Math.sqrt(dominant.re * dominant.re + dominant.im * dominant.im);
            const zeta = -dominant.re / wn;
            document.getElementById('dampingRatio').textContent = zeta.toFixed(3);
        }
        
        function drawAll() {
            drawPoleCanvas();
            drawResponseCanvas();
            updateEigenvalueList();
            updateStabilityStatus();
            updateResponseCharacteristics();
        }
        
        // 2æ¬¡ç³»ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        function updateSecondOrder() {
            const zeta = parseFloat(document.getElementById('zetaSlider').value);
            const wn = parseFloat(document.getElementById('wnSlider').value);
            
            document.getElementById('zetaVal').textContent = zeta.toFixed(2);
            document.getElementById('wnVal').textContent = wn.toFixed(1);
            
            // æ¥µã®è¨ˆç®—
            let polesStr;
            if (zeta < 1) {
                const sigma = -zeta * wn;
                const omega = wn * Math.sqrt(1 - zeta * zeta);
                polesStr = `s = ${sigma.toFixed(2)} Â± ${omega.toFixed(2)}j`;
            } else if (zeta === 1) {
                polesStr = `s = ${(-wn).toFixed(2)} (é‡æ ¹)`;
            } else {
                const p1 = -zeta * wn + wn * Math.sqrt(zeta * zeta - 1);
                const p2 = -zeta * wn - wn * Math.sqrt(zeta * zeta - 1);
                polesStr = `s = ${p1.toFixed(2)}, ${p2.toFixed(2)}`;
            }
            document.getElementById('secondOrderPoles').textContent = polesStr;
            
            drawSecondOrderResponse(zeta, wn);
        }
        
        function drawSecondOrderResponse(zeta, wn) {
            const w = secondOrderCanvas.getBoundingClientRect().width;
            const h = secondOrderCanvas.getBoundingClientRect().height;
            
            secondOrderCtx.fillStyle = 'rgba(0,0,0,0.3)';
            secondOrderCtx.fillRect(0, 0, w, h);
            
            const margin = { top: 20, right: 20, bottom: 30, left: 40 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            // ã‚¹ãƒ†ãƒƒãƒ—å¿œç­”è¨ˆç®—
            const maxT = 10;
            const dt = 0.02;
            const data = [];
            
            for (let t = 0; t <= maxT; t += dt) {
                let y;
                if (zeta < 1) {
                    const wd = wn * Math.sqrt(1 - zeta * zeta);
                    const phi = Math.atan2(zeta, Math.sqrt(1 - zeta * zeta));
                    y = 1 - Math.exp(-zeta * wn * t) * Math.cos(wd * t - phi) / Math.sqrt(1 - zeta * zeta);
                } else if (zeta === 1) {
                    y = 1 - (1 + wn * t) * Math.exp(-wn * t);
                } else {
                    const s1 = -zeta * wn + wn * Math.sqrt(zeta * zeta - 1);
                    const s2 = -zeta * wn - wn * Math.sqrt(zeta * zeta - 1);
                    y = 1 + (s1 * Math.exp(s2 * t) - s2 * Math.exp(s1 * t)) / (s2 - s1);
                }
                data.push({ t, y });
            }
            
            const toX = (t) => margin.left + (t / maxT) * plotW;
            const toY = (y) => margin.top + plotH - (y / 1.6) * plotH;
            
            // ã‚°ãƒªãƒƒãƒ‰
            secondOrderCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            secondOrderCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = margin.top + (plotH / 4) * i;
                secondOrderCtx.beginPath();
                secondOrderCtx.moveTo(margin.left, y);
                secondOrderCtx.lineTo(w - margin.right, y);
                secondOrderCtx.stroke();
            }
            
            // ç›®æ¨™å€¤
            secondOrderCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            secondOrderCtx.setLineDash([5, 5]);
            secondOrderCtx.beginPath();
            secondOrderCtx.moveTo(margin.left, toY(1));
            secondOrderCtx.lineTo(w - margin.right, toY(1));
            secondOrderCtx.stroke();
            secondOrderCtx.setLineDash([]);
            
            // å¿œç­”æ›²ç·š
            secondOrderCtx.strokeStyle = 'var(--accent)';
            secondOrderCtx.lineWidth = 2;
            secondOrderCtx.beginPath();
            data.forEach((p, i) => {
                if (i === 0) secondOrderCtx.moveTo(toX(p.t), toY(p.y));
                else secondOrderCtx.lineTo(toX(p.t), toY(p.y));
            });
            secondOrderCtx.stroke();
            
            // ãƒ©ãƒ™ãƒ«
            secondOrderCtx.fillStyle = 'var(--dim)';
            secondOrderCtx.font = '10px JetBrains Mono';
            secondOrderCtx.fillText('t [s]', w - 30, h - 10);
            secondOrderCtx.fillText('y(t)', margin.left + 5, margin.top + 15);
        }
        
        document.getElementById('zetaSlider').addEventListener('input', updateSecondOrder);
        document.getElementById('wnSlider').addEventListener('input', updateSecondOrder);
        
        window.addEventListener('load', () => {
            initCanvases();
            updateSecondOrder();
        });
        window.addEventListener('resize', () => { initCanvases(); updateSecondOrder(); });
    </script>
</body>
</html>
